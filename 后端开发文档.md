# 餐厅积分抽奖系统 - 后端开发文档

> **基于开发总文档1号和前端1号文档的后端实现指导**

## 🎯 文档概述

本文档根据开发总文档1号和前端1号文档的要求，详细说明后端API开发、业务逻辑实现和系统部署配置。包含完整的接口规范、数据库对接、实时通信、安全机制等后端开发的所有关键点。

---

## 🗄️ 一、数据库环境配置

### 1.1 数据库连接信息
```javascript
// 数据库配置
const dbConfig = {
  development: {
    host: 'test-db-mysql.ns-br0za7uc.svc',
    port: 3306,
    user: 'root',
    password: 'mc6r9cgb',
    database: 'restaurant_points_dev',
    connectionString: 'mysql://root:mc6r9cgb@test-db-mysql.ns-br0za7uc.svc:3306/restaurant_points_dev'
  },
  production: {
    host: 'dbconn.sealosbja.site',
    port: 42182,
    user: 'root', 
    password: 'mc6r9cgb',
    database: 'restaurant_points_prod',
    connectionString: 'mysql://root:mc6r9cgb@dbconn.sealosbja.site:42182/restaurant_points_prod'
  }
}
```

### 1.2 服务器部署配置
```javascript
// Devbox服务器配置
const serverConfig = {
  devbox: {
    name: 'devbox1',
    port: 3000,
    internalUrl: 'http://devbox1.ns-br0za7uc.svc.cluster.local:3000',
    publicUrl: 'https://rqchrlqndora.sealosbja.site'
  }
}
```

### 1.3 Sealos对象存储配置
```javascript
// 🔴 Sealos对象存储配置 - 用户提供的真实配置
const sealosConfig = {
  bucket: 'tiangong',
  accessKeyId: 'br0za7uc',
  secretAccessKey: 'skxg8mk5gqfhf9xz',
  endpoint: {
    internal: 'http://object-storage.objectstorage-system.svc.cluster.local',
    external: 'https://objectstorageapi.bja.sealos.run'
  },
  // 根据环境自动选择端点
  getEndpoint: () => {
    return process.env.NODE_ENV === 'production' 
      ? sealosConfig.endpoint.external 
      : sealosConfig.endpoint.internal;
  }
}
```

---

## 🔌 二、核心API接口实现

### 2.1 认证授权系统

#### 🔑 用户登录认证
```javascript
// POST /api/auth/login
// 🔴 前端对接点1：手机号验证码登录
app.post('/api/auth/login', async (req, res) => {
  try {
    const { phone, code } = req.body;
    
    // 1. 验证手机号格式
    if (!/^1[3-9]\d{9}$/.test(phone)) {
      return res.json({
        code: 1001,
        msg: '手机号格式不正确',
        data: null
      });
    }
    
    // 2. 验证验证码（开发环境可放宽）
    const isValidCode = await verifyCode(phone, code);
    if (!isValidCode && process.env.NODE_ENV === 'production') {
      return res.json({
        code: 1002,
        msg: '验证码错误或已过期',
        data: null
      });
    }
    
    // 3. 查询或创建用户
    let user = await User.findOne({ mobile: phone });
    if (!user) {
      user = await User.create({
        mobile: phone,
        total_points: 1000, // 新用户奖励1000积分
        nickname: `用户${phone.slice(-4)}`,
        created_at: new Date()
      });
    }
    
    // 4. 生成JWT Token
    const accessToken = jwt.sign(
      { 
        user_id: user.user_id,
        mobile: user.mobile,
        is_merchant: user.is_merchant 
      },
      process.env.JWT_SECRET,
      { expiresIn: '2h' }
    );
    
    const refreshToken = jwt.sign(
      { user_id: user.user_id },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    // 5. 更新登录时间
    await User.update(
      { last_login: new Date() },
      { where: { user_id: user.user_id } }
    );
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        access_token: accessToken,
        refresh_token: refreshToken,
        expires_in: 7200,
        user_info: {
          user_id: user.user_id,
          mobile: user.mobile.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2'),
          nickname: user.nickname,
          avatar: user.avatar,
          total_points: user.total_points,
          is_merchant: user.is_merchant
        }
      }
    });
  } catch (error) {
    console.error('登录失败:', error);
    res.json({
      code: 1000,
      msg: '系统异常，请稍后重试',
      data: null
    });
  }
});
```

#### 🔄 Token刷新机制
```javascript
// POST /api/auth/refresh
// 🔴 前端对接点2：自动刷新Token
app.post('/api/auth/refresh', async (req, res) => {
  try {
    const refreshToken = req.headers.authorization?.replace('Bearer ', '');
    
    if (!refreshToken) {
      return res.json({
        code: 2001,
        msg: 'Refresh Token不能为空',
        data: null
      });
    }
    
    // 验证Refresh Token
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
    const user = await User.findByPk(decoded.user_id);
    
    if (!user) {
      return res.json({
        code: 2002,
        msg: '用户不存在',
        data: null
      });
    }
    
    // 生成新的Token
    const accessToken = jwt.sign(
      { 
        user_id: user.user_id,
        mobile: user.mobile,
        is_merchant: user.is_merchant 
      },
      process.env.JWT_SECRET,
      { expiresIn: '2h' }
    );
    
    const newRefreshToken = jwt.sign(
      { user_id: user.user_id },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        access_token: accessToken,
        refresh_token: newRefreshToken,
        expires_in: 7200
      }
    });
  } catch (error) {
    console.error('Token刷新失败:', error);
    res.json({
      code: 2000,
      msg: 'Token无效或已过期',
      data: null
    });
  }
});
```

### 2.2 抽奖系统实现

#### 🎰 抽奖配置接口
```javascript
// GET /api/lottery/config
// 🔴 前端对接点3：获取转盘配置数据
app.get('/api/lottery/config', authenticateToken, async (req, res) => {
  try {
    // 获取抽奖配置
    const prizes = await LotterySetting.findAll({
      where: { status: 'active' },
      order: [['angle', 'ASC']]
    });
    
    // 计算总概率（验证配置正确性）
    const totalProbability = prizes.reduce((sum, prize) => sum + parseFloat(prize.probability), 0);
    
    if (Math.abs(totalProbability - 1.0) > 0.001) {
      console.error('抽奖概率配置错误，总概率不等于1:', totalProbability);
    }
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        cost_points: 100, // 单次抽奖消耗积分
        prizes: prizes.map(prize => ({
          id: prize.prize_id,
          name: prize.prize_name,
          type: prize.prize_type,
          value: prize.prize_value,
          angle: prize.angle,
          color: prize.color,
          probability: prize.probability,
          is_activity: prize.is_activity // 🔴 触发特殊动效
        }))
      }
    });
  } catch (error) {
    console.error('获取抽奖配置失败:', error);
    res.json({
      code: 3000,
      msg: '获取配置失败',
      data: null
    });
  }
});
```

#### 🎯 执行抽奖接口
```javascript
// POST /api/lottery/draw
// 🔴 前端对接点4：执行抽奖逻辑
app.post('/api/lottery/draw', authenticateToken, async (req, res) => {
  try {
    const { draw_type, count } = req.body;
    const userId = req.user.user_id;
    
    // 验证抽奖次数
    const drawCounts = {
      'single': 1,
      'triple': 3, 
      'quintuple': 5,
      'decade': 10
    };
    
    const actualCount = drawCounts[draw_type] || 1;
    const totalCost = actualCount * 100; // 每次100积分
    
    // 检查积分余额
    const user = await User.findByPk(userId);
    if (user.total_points < totalCost) {
      return res.json({
        code: 3001,
        msg: '积分余额不足',
        data: { required: totalCost, current: user.total_points }
      });
    }
    
    // 获取抽奖配置
    const prizes = await LotterySetting.findAll({
      where: { status: 'active' },
      order: [['angle', 'ASC']]
    });
    
    // 执行抽奖
    const results = [];
    for (let i = 0; i < actualCount; i++) {
      const result = await performLottery(prizes, userId);
      results.push(result);
    }
    
    // 扣除积分
    await User.decrement('total_points', {
      by: totalCost,
      where: { user_id: userId }
    });
    
    // 记录积分变动
    await PointsRecord.create({
      user_id: userId,
      type: 'spend',
      points: -totalCost,
      description: `${draw_type}抽奖`,
      source: 'lottery',
      balance_after: user.total_points - totalCost
    });
    
    // 🔴 发送WebSocket通知积分变更
    await notifyPointsUpdate(userId, user.total_points - totalCost, -totalCost, '抽奖消费');
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        results: results,
        points_cost: totalCost,
        remaining_points: user.total_points - totalCost
      }
    });
  } catch (error) {
    console.error('抽奖失败:', error);
    res.json({
      code: 3000,
      msg: '抽奖失败，请稍后重试',
      data: null
    });
  }
});

// 抽奖核心算法
async function performLottery(prizes, userId) {
  const random = Math.random();
  let cumulativeProbability = 0;
  
  for (const prize of prizes) {
    cumulativeProbability += parseFloat(prize.probability);
    
    if (random <= cumulativeProbability) {
      // 🔴 检查是否触发"差点中奖"动效
      const isNearMiss = checkNearMiss(random, cumulativeProbability, prize);
      
      // 记录抽奖结果
      await LotteryRecord.create({
        user_id: userId,
        prize_id: prize.prize_id,
        prize_name: prize.prize_name,
        prize_type: prize.prize_type,
        prize_value: prize.prize_value,
        is_near_miss: isNearMiss
      });
      
      return {
        prize_id: prize.prize_id,
        prize_name: prize.prize_name,
        prize_type: prize.prize_type,
        prize_value: prize.prize_value,
        angle: prize.angle,
        is_near_miss: isNearMiss // 🔴 前端根据此字段播放抖动动画
      };
    }
  }
  
  // 兜底：返回最后一个奖品（通常是谢谢参与）
  const lastPrize = prizes[prizes.length - 1];
  return {
    prize_id: lastPrize.prize_id,
    prize_name: lastPrize.prize_name,
    prize_type: lastPrize.prize_type,
    prize_value: lastPrize.prize_value,
    angle: lastPrize.angle,
    is_near_miss: false
  };
}

// 检查"差点中奖"逻辑
function checkNearMiss(random, cumulativeProbability, prize) {
  // 如果是特殊奖品且随机数接近边界，触发差点中奖
  if (prize.is_activity) {
    const previousBoundary = cumulativeProbability - parseFloat(prize.probability);
    const distanceFromStart = random - previousBoundary;
    const distanceFromEnd = cumulativeProbability - random;
    
    // 如果距离边界很近，触发差点中奖动效
    return distanceFromStart < 0.02 || distanceFromEnd < 0.02;
  }
  return false;
}
```

### 2.3 商品兑换系统

#### 🛍️ 商品列表接口
```javascript
// GET /api/exchange/products
// 🔴 前端对接点5：支持筛选分页的商品列表
app.get('/api/exchange/products', authenticateToken, async (req, res) => {
  try {
    const { 
      category, 
      min_points, 
      max_points, 
      stock_status, 
      sort_by = 'sort_order',
      sort_order = 'ASC',
      page = 1, 
      limit = 20 
    } = req.query;
    
    // 构建查询条件
    const whereClause = { status: 'active' };
    
    if (category && category !== '全部') {
      whereClause.category = category;
    }
    
    if (min_points) {
      whereClause.exchange_points = { [Op.gte]: parseInt(min_points) };
    }
    
    if (max_points) {
      if (whereClause.exchange_points) {
        whereClause.exchange_points[Op.lte] = parseInt(max_points);
      } else {
        whereClause.exchange_points = { [Op.lte]: parseInt(max_points) };
      }
    }
    
    if (stock_status === 'in_stock') {
      whereClause.stock = { [Op.gt]: 0 };
    } else if (stock_status === 'out_of_stock') {
      whereClause.stock = 0;
    }
    
    // 分页查询
    const offset = (parseInt(page) - 1) * parseInt(limit);
    const { count, rows } = await CommodityPool.findAndCountAll({
      where: whereClause,
      order: [[sort_by, sort_order.toUpperCase()]],
      limit: parseInt(limit),
      offset: offset
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        products: rows.map(product => ({
          id: product.commodity_id,
          name: product.name,
          description: product.description,
          category: product.category,
          exchange_points: product.exchange_points,
          stock: product.stock, // 🔴 实时库存显示
          image: product.image,
          is_hot: product.is_hot,
          rating: product.rating,
          sales_count: product.sales_count,
          status: product.stock > 0 ? 'available' : 'sold_out'
        })),
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit))
        }
      }
    });
  } catch (error) {
    console.error('获取商品列表失败:', error);
    res.json({
      code: 4000,
      msg: '获取商品列表失败',
      data: null
    });
  }
});
```

#### 💰 商品兑换接口
```javascript
// POST /api/exchange/redeem
// 🔴 前端对接点6：执行商品兑换
app.post('/api/exchange/redeem', authenticateToken, async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { commodity_id, quantity = 1, delivery_info } = req.body;
    const userId = req.user.user_id;
    
    // 查询商品信息
    const product = await CommodityPool.findByPk(commodity_id, { transaction });
    if (!product) {
      await transaction.rollback();
      return res.json({
        code: 4001,
        msg: '商品不存在',
        data: null
      });
    }
    
    // 检查库存
    if (product.stock < quantity) {
      await transaction.rollback();
      return res.json({
        code: 4002,
        msg: '库存不足',
        data: { available: product.stock, requested: quantity }
      });
    }
    
    // 检查积分余额
    const totalCost = product.exchange_points * quantity;
    const user = await User.findByPk(userId, { transaction });
    
    if (user.total_points < totalCost) {
      await transaction.rollback();
      return res.json({
        code: 4003,
        msg: '积分余额不足',
        data: { required: totalCost, current: user.total_points }
      });
    }
    
    // 扣减库存
    await CommodityPool.decrement('stock', {
      by: quantity,
      where: { commodity_id: commodity_id },
      transaction
    });
    
    // 扣减积分
    await User.decrement('total_points', {
      by: totalCost,
      where: { user_id: userId },
      transaction
    });
    
    // 创建兑换记录
    const orderNumber = generateOrderNumber();
    const exchangeRecord = await ExchangeRecord.create({
      user_id: userId,
      commodity_id: commodity_id,
      order_id: orderNumber,
      product_name: product.name,
      quantity: quantity,
      points_cost: totalCost,
      status: 'pending',
      delivery_info: delivery_info
    }, { transaction });
    
    // 记录积分变动
    await PointsRecord.create({
      user_id: userId,
      type: 'spend',
      points: -totalCost,
      description: `兑换商品：${product.name}`,
      source: 'exchange',
      balance_after: user.total_points - totalCost
    }, { transaction });
    
    await transaction.commit();
    
    // 🔴 发送WebSocket库存更新通知
    await notifyStockUpdate(commodity_id, product.stock - quantity, 'purchase');
    
    // 🔴 发送积分变更通知
    await notifyPointsUpdate(userId, user.total_points - totalCost, -totalCost, '商品兑换');
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        order_id: orderNumber,
        product_name: product.name,
        quantity: quantity,
        points_cost: totalCost,
        remaining_points: user.total_points - totalCost,
        status: 'pending'
      }
    });
  } catch (error) {
    await transaction.rollback();
    console.error('商品兑换失败:', error);
    res.json({
      code: 4000,
      msg: '兑换失败，请稍后重试',
      data: null
    });
  }
});

// 生成订单号
function generateOrderNumber() {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `EX${timestamp}${random}`;
}
```

### 2.4 拍照上传系统

#### 📸 图片上传与AI识别
```javascript
// POST /api/photo/upload
// 🔴 前端对接点7：图片上传+OCR识别
const multer = require('multer');
const sealosStorage = require('../services/sealosStorage');

const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB限制
});

app.post('/api/photo/upload', authenticateToken, upload.single('file'), async (req, res) => {
  try {
    const { amount } = req.body;
    const userId = req.user.user_id;
    const file = req.file;
    
    if (!file) {
      return res.json({
        code: 5001,
        msg: '请选择要上传的图片',
        data: null
      });
    }
    
    // 🔴 上传到Sealos对象存储（使用真实配置）
    const imageUrl = await sealosStorage.uploadImage(
      file.buffer, 
      file.originalname, 
      'receipt-photos'
    );
    
    // AI识别金额（调用OCR服务）
    const recognizedAmount = await performOCR(imageUrl);
    
    // 计算积分奖励（金额×10）
    const inputAmount = parseFloat(amount);
    const aiAmount = recognizedAmount || inputAmount;
    const pointsAwarded = Math.floor(aiAmount * 10);
    
    // 限制积分范围
    const finalPoints = Math.max(50, Math.min(2000, pointsAwarded));
    
    // 判断匹配状态
    let matchStatus = 'unclear';
    if (recognizedAmount) {
      const difference = Math.abs(recognizedAmount - inputAmount);
      if (difference <= 0.5) {
        matchStatus = 'matched';
      } else {
        matchStatus = 'mismatched';
      }
    }
    
    // 生成上传ID
    const uploadId = generateUploadId();
    
    // 创建审核记录
    await PhotoReview.create({
      user_id: userId,
      upload_id: uploadId,
      image_url: imageUrl,
      input_amount: inputAmount,
      recognized_amount: recognizedAmount,
      match_status: matchStatus,
      points_awarded: finalPoints,
      review_status: 'pending'
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        upload_id: uploadId,
        image_url: imageUrl,
        input_amount: inputAmount,
        recognized_amount: recognizedAmount, // 🔴 AI识别金额
        points_awarded: finalPoints, // 🔴 计算的积分奖励
        match_status: matchStatus, // 🔴 匹配状态
        review_status: 'pending' // 🔴 审核状态
      }
    });
  } catch (error) {
    console.error('图片上传失败:', error);
    res.json({
      code: 5000,
      msg: '上传失败，请稍后重试',
      data: null
    });
  }
});

// 生成上传ID
function generateUploadId() {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `UP${timestamp}${random}`;
}
```

---

## 🌐 三、WebSocket实时通信实现

### 3.1 WebSocket服务器配置
```javascript
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');

// 创建WebSocket服务器
const wss = new WebSocket.Server({ 
  port: 8080,
  verifyClient: (info) => {
    // 验证WebSocket连接的Token
    const token = new URL(info.req.url, 'http://localhost').searchParams.get('token');
    try {
      jwt.verify(token, process.env.JWT_SECRET);
      return true;
    } catch (error) {
      return false;
    }
  }
});

// 用户连接映射
const userConnections = new Map();

wss.on('connection', (ws, req) => {
  // 提取用户信息
  const token = new URL(req.url, 'http://localhost').searchParams.get('token');
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  const userId = decoded.user_id;
  
  // 存储用户连接
  userConnections.set(userId, ws);
  
  console.log(`用户 ${userId} 已连接WebSocket`);
  
  // 处理消息
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      handleWebSocketMessage(userId, data, ws);
    } catch (error) {
      console.error('WebSocket消息解析失败:', error);
    }
  });
  
  // 处理断开连接
  ws.on('close', () => {
    userConnections.delete(userId);
    console.log(`用户 ${userId} 已断开WebSocket连接`);
  });
  
  // 发送连接确认
  ws.send(JSON.stringify({
    type: 'connected',
    timestamp: new Date().toISOString(),
    message: '连接成功'
  }));
});

// 处理WebSocket消息
function handleWebSocketMessage(userId, data, ws) {
  switch (data.type) {
    case 'ping':
      // 🔴 心跳机制
      ws.send(JSON.stringify({
        type: 'pong',
        timestamp: Date.now(),
        server_time: new Date().toISOString()
      }));
      break;
      
    case 'subscribe_product':
      // 订阅商品库存更新
      ws.subscribedProducts = data.product_ids || [];
      break;
      
    default:
      console.log('未知的WebSocket消息类型:', data.type);
  }
}
```

### 3.2 实时通知功能
```javascript
// 🔴 库存变更推送
async function notifyStockUpdate(productId, newStock, operation) {
  const message = {
    type: 'stock_update',
    data: {
      product_id: productId,
      stock: newStock,
      operation: operation, // purchase/restock/admin_adjust
      timestamp: new Date().toISOString()
    }
  };
  
  // 广播给所有连接的用户
  userConnections.forEach((ws, userId) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  });
}

// 🔴 积分变更推送
async function notifyPointsUpdate(userId, totalPoints, changePoints, reason) {
  const ws = userConnections.get(userId);
  if (ws && ws.readyState === WebSocket.OPEN) {
    const message = {
      type: 'points_update',
      data: {
        user_id: userId,
        total_points: totalPoints,
        change_points: changePoints,
        reason: reason,
        timestamp: new Date().toISOString()
      }
    };
    
    ws.send(JSON.stringify(message));
  }
}

// 🔴 审核结果推送
async function notifyReviewResult(userId, uploadId, status, pointsAwarded, reason) {
  const ws = userConnections.get(userId);
  if (ws && ws.readyState === WebSocket.OPEN) {
    const message = {
      type: 'review_result',
      data: {
        upload_id: uploadId,
        status: status, // approved/rejected
        points_awarded: pointsAwarded,
        review_reason: reason,
        timestamp: new Date().toISOString()
      }
    };
    
    ws.send(JSON.stringify(message));
  }
}
```

---

## 🔒 四、安全机制实现

### 4.1 JWT认证中间件
```javascript
// JWT认证中间件
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.json({
      code: 2001,
      msg: '访问令牌不能为空',
      data: null
    });
  }
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.json({
        code: 2002,
        msg: '访问令牌无效或已过期',
        data: null
      });
    }
    
    req.user = user;
    next();
  });
}
```

### 4.2 请求限流中间件
```javascript
const rateLimit = require('express-rate-limit');

// 🔴 防刷机制：API限流
const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1分钟
  max: 60, // 限制每个IP每分钟60次请求
  message: {
    code: 3001,
    msg: '请求过于频繁，请稍后再试',
    data: null
  },
  standardHeaders: true,
  legacyHeaders: false
});

// 抽奖限流（更严格）
const lotteryLimiter = rateLimit({
  windowMs: 60 * 1000, // 1分钟
  max: 3, // 限制每个用户每分钟3次抽奖
  keyGenerator: (req) => req.user?.user_id || req.ip,
  message: {
    code: 3002,
    msg: '抽奖过于频繁，请稍后再试',
    data: null
  }
});

// 应用限流中间件
app.use('/api/', apiLimiter);
app.use('/api/lottery/draw', lotteryLimiter);
```

### 4.3 数据加密
```javascript
const crypto = require('crypto');

// 敏感数据加密
function encryptSensitiveData(data) {
  const algorithm = 'aes-256-gcm';
  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
  const iv = crypto.randomBytes(16);
  
  const cipher = crypto.createCipher(algorithm, key);
  cipher.setAAD(Buffer.from('sensitive_data'));
  
  let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return {
    encrypted,
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex')
  };
}

// 敏感数据解密
function decryptSensitiveData(encryptedData) {
  const algorithm = 'aes-256-gcm';
  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
  
  const decipher = crypto.createDecipher(algorithm, key);
  decipher.setAAD(Buffer.from('sensitive_data'));
  decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
  
  let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return JSON.parse(decrypted);
}
```

---

## 📊 五、性能监控实现

### 5.1 性能指标收集
```javascript
// POST /api/monitoring/performance
// 🔴 前端性能数据上报
app.post('/api/monitoring/performance', authenticateToken, async (req, res) => {
  try {
    const {
      api_response_time,
      canvas_render_fps,
      page_load_time,
      memory_usage,
      error_rate
    } = req.body;
    
    // 存储性能数据
    await PerformanceMetric.create({
      user_id: req.user.user_id,
      api_response_time,
      canvas_render_fps,
      page_load_time,
      memory_usage,
      error_rate,
      timestamp: new Date()
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: null
    });
  } catch (error) {
    console.error('性能数据收集失败:', error);
    res.json({
      code: 6000,
      msg: '数据收集失败',
      data: null
    });
  }
});
```

### 5.2 错误日志收集
```javascript
// POST /api/monitoring/errors
// 🔴 前端错误日志上报
app.post('/api/monitoring/errors', async (req, res) => {
  try {
    const {
      message,
      stack,
      page,
      user_id
    } = req.body;
    
    // 存储错误日志
    await ErrorLog.create({
      user_id,
      error_message: message,
      error_stack: stack,
      page_route: page,
      timestamp: new Date()
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: null
    });
  } catch (error) {
    console.error('错误日志收集失败:', error);
    res.json({
      code: 6001,
      msg: '日志收集失败',
      data: null
    });
  }
});
```

---

## 🚀 六、部署配置

### 6.1 环境变量配置
```bash
# .env 环境变量配置文件
NODE_ENV=production
PORT=3000

# 数据库配置
DB_HOST=test-db-mysql.ns-br0za7uc.svc
DB_PORT=3306
DB_USER=root
DB_PASSWORD=mc6r9cgb
DB_NAME=restaurant_points

# JWT配置
JWT_SECRET=your_jwt_secret_key_here
JWT_REFRESH_SECRET=your_refresh_secret_key_here

# 加密配置
ENCRYPTION_KEY=your_encryption_key_32_bytes_hex

# 🔴 Sealos存储配置 - 用户提供的真实配置
SEALOS_ENDPOINT=https://objectstorageapi.bja.sealos.run
SEALOS_INTERNAL_ENDPOINT=http://object-storage.objectstorage-system.svc.cluster.local
SEALOS_BUCKET=tiangong
SEALOS_ACCESS_KEY=br0za7uc
SEALOS_SECRET_KEY=skxg8mk5gqfhf9xz

# OCR服务配置
OCR_API_KEY=your_ocr_api_key
OCR_SECRET_KEY=your_ocr_secret_key

# WebSocket配置
WS_PORT=8080
```

### 6.2 Docker部署配置
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# 复制package.json
COPY package*.json ./

# 安装依赖
RUN npm install --production

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 3000 8080

# 启动命令
CMD ["npm", "start"]
```

### 6.3 部署脚本
```bash
#!/bin/bash
# deploy.sh - 部署脚本

echo "开始部署餐厅积分抽奖系统后端..."

# 1. 构建Docker镜像
docker build -t restaurant-points-backend .

# 2. 停止旧容器
docker stop restaurant-points-backend 2>/dev/null || true
docker rm restaurant-points-backend 2>/dev/null || true

# 3. 启动新容器
docker run -d \
  --name restaurant-points-backend \
  --restart unless-stopped \
  -p 3000:3000 \
  -p 8080:8080 \
  --env-file .env \
  restaurant-points-backend

echo "部署完成！"
echo "API服务地址: http://devbox1.ns-br0za7uc.svc.cluster.local:3000"
echo "WebSocket地址: ws://devbox1.ns-br0za7uc.svc.cluster.local:8080"
echo "公网访问地址: https://rqchrlqndora.sealosbja.site"
```

---

## 📋 七、对接检查清单

### 7.1 API接口检查
- [ ] ✅ 认证接口 `/api/auth/login` 正常工作
- [ ] ✅ Token刷新 `/api/auth/refresh` 正常工作
- [ ] ✅ 抽奖配置 `/api/lottery/config` 返回正确数据
- [ ] ✅ 抽奖执行 `/api/lottery/draw` 支持批量抽奖
- [ ] ✅ 商品列表 `/api/exchange/products` 支持筛选分页
- [ ] ✅ 商品兑换 `/api/exchange/redeem` 事务完整性
- [ ] ✅ 图片上传 `/api/photo/upload` 集成OCR识别
- [ ] ✅ 商家审核 `/api/merchant/review` 权限验证

### 7.2 WebSocket通信检查
- [ ] ✅ WebSocket连接认证机制
- [ ] ✅ 库存变更实时推送
- [ ] ✅ 积分变更实时推送
- [ ] ✅ 审核结果实时推送
- [ ] ✅ 心跳保活机制

### 7.3 安全机制检查
- [ ] ✅ JWT双令牌认证
- [ ] ✅ API请求限流
- [ ] ✅ 敏感数据加密
- [ ] ✅ 防刷机制启用
- [ ] ✅ HTTPS强制跳转

### 7.4 数据库连接检查
- [ ] ✅ 内网数据库连接正常
- [ ] ✅ 外网数据库连接正常
- [ ] ✅ 数据库事务机制
- [ ] ✅ 连接池配置优化
- [ ] ✅ 索引创建完成

---

> **🔴 重要提醒**: 
> 1. 所有API接口必须严格按照前端1号文档的要求实现
> 2. WebSocket消息格式必须与前端保持一致
> 3. 数据库字段映射必须完全匹配前端需求
> 4. 安全机制和性能监控必须在生产环境启用

> **🚀 部署建议**:
> 1. 使用提供的数据库连接信息进行开发测试
> 2. 在Devbox1环境中部署和调试
> 3. 确保所有环境变量正确配置
> 4. 建立完整的监控和日志系统 